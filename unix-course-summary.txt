ðŸ—’ï¸ UNIX WORKBENCH â€“ 
DAY 1 SUMMARY

ðŸ“‚ Navigating Directories:
- pwd â†’ prints current location
- cd ~ â†’ go to home directory
- cd / â†’ go to root directory
- cd folder_name â†’ enter a subdirectory
- cd .. â†’ move one directory up
- cd /path/to/folder â†’ absolute path navigation

ðŸ“„ Folder Management:
- mkdir folder_name â†’ create directory
- ls â†’ list files and folders
- rm -r folder_name â†’ delete directory (carefulâ€”no confirmation)

ðŸ§­ Paths:
- Absolute path: starts with / (e.g., /mnt/c/BioEdit)
- Relative path: based on current directory (e.g., ../other_folder)

âŒ¨ï¸ Tab Completion:
- Tab completes folder/file names
- Double Tab â†’ lists all matching options

ðŸªŸ Accessing Windows from Linux:
- /mnt/c/... â†’ access Windows C drive
- Example: cd /mnt/c/Users/Shalev/Desktop

ðŸ“Ž Tips:
- Use pwd to verify location
- Use ls to see contents before cd
- Avoid rm -r unless youâ€™re sure


ðŸ—’ï¸ UNIX WORKBENCH â€“ DAY 2 SUMMARY

UNIX WORKBENCH â€“ DAY 2 SUMMARY

File and Directory Management:
------------------------------
mkdir my_folder
    â†’ Create a new directory named 'my_folder'

touch notes.txt
    â†’ Create an empty file named 'notes.txt'

cp notes.txt backup.txt
    â†’ Copy file to a new file named 'backup.txt'

mv backup.txt archive/
    â†’ Move file to a folder or rename it

rm notes.txt
rm -r archive/
    â†’ Delete file or folder (with all contents). Use carefully.

Writing and Appending to Files:
-------------------------------
echo "Hello" > file.txt
    â†’ Write to file (overwrites existing content)

echo "Another line" >> file.txt
    â†’ Append new content to the end of the file

Viewing File Content:
---------------------
cat file.txt
    â†’ Print the full content of the file

head file.txt
    â†’ Print the first 10 lines of the file

tail file.txt
    â†’ Print the last 10 lines of the file

less file.txt
    â†’ Scroll through file content (use q to quit)

File Statistics:
----------------
wc file.txt
    â†’ Print number of lines, words, and characters

Output Redirection:
-------------------
ls ~ > list.txt
    â†’ Save a list of files in the home directory to list.txt

ls ~ >> list.txt
    â†’ Append the file list to the same file

Module 2

Help and Manual:
----------------
man ls
    â†’ Show help documentation for a command

apropos calendar
    â†’ Search for commands related to a keyword

Wildcards:
----------
ls *.txt
    â†’ List all files ending with .txt

rm temp*
    â†’ Delete all files starting with 'temp'

Trash Recommendation:
---------------------
mkdir -p ~/.Trash
mv file.txt ~/.Trash/
    â†’ Instead of deleting a file, move it to a custom Trash folder

Tips:
-----
- Use pwd to verify current location
- Use ls to check contents before using cd
- Avoid rm -r unless you're completely sure


REGULAR EXPRESSIONS & TEXT SEARCHING:

ðŸ” Basic Commands:
- grep "pattern" filename        â†’ search for lines matching pattern
- egrep "pattern" filename       â†’ like grep, but supports extended regex
- find /path -name "filename"    â†’ search for file names in directories

# The -i flag in egrep (or grep) makes the search case-insensitive.
# This means it ignores the difference between uppercase and lowercase letters.

# The following command finds lowercase or uppercase:
egrep -i "^[aeiou]" states.txt
# This is equivalent to writing:
egrep "^[AEIOUaeiou]" states.txt

ðŸ§  Common Regex Metacharacters:
.       â†’ Any single character
\w      â†’ Word character (a-z, A-Z, 0-9, _)
\W      â†’ Not a word character
\d      â†’ Digit (0â€“9)
\D      â†’ Not a digit
\s      â†’ Whitespace (space, tab, etc.)
\S      â†’ Not whitespace
\n      â†’ Newline

ðŸ”£ Sets and Ranges:
[abc]   â†’ Match 'a' or 'b' or 'c'
[^abc]  â†’ Match anything except 'a', 'b', or 'c'
[a-z]   â†’ Range from 'a' to 'z'

ðŸ“ Anchors:
^       â†’ Start of string "^[aeiou]" / "^M"
$       â†’ End of string "[aeiou]$"

ðŸ”¢ Quantifiers:
+       â†’ One or more of the previous
*       â†’ Zero or more of the previous
?       â†’ Zero or one of the previous
{n}     â†’ Exactly n occurrences
{m,n}   â†’ Between m and n occurrences
{m,}    â†’ m or more occurrences

ðŸ” Alternation:
|       â†’ OR between expressions (e.g. food|bar)

ðŸ§ª Examples:
egrep "s+as" states.txt  
â†’ Matches lines with 's' repeated 1+ times followed by 'as'  
  â†’ Matches: Kansas, Arkansas

egrep "\d" small.txt  
â†’ Matches lines containing digits

egrep "\W" small.txt  
â†’ Matches lines containing symbols or spaces (non-word characters)

egrep "New" states.txt  
â†’ Matches: New York, New Mexico, etc.

ðŸ“Œ Tip:
Use `egrep -v` to invert the match (i.e. return non-matching lines)



# ðŸ“˜ Bash History and Aliases Summary

# View command history in the current terminal session
history

# View full command history saved across sessions
cat ~/.bash_history

# Create an alias for a frequently used command
alias ll="ls -lh"

# Make aliases persist across sessions by adding them to this file:
~/.bash_profile

# Example: Add the following line to ~/.bash_profile
# alias gs="git status"

# To apply changes without restarting the shell:
source ~/.bash_profile

# Tip:
# Use `history | grep keyword` to search past commands


# ðŸ” Hashing and File Integrity Verification

# shasum â€“ generates a SHA-1 checksum (hash) based on file content.
# Useful to verify file authenticity and detect corruption.

# Syntax:
shasum filename

# Example:
shasum file1.txt
# Output: a long hexadecimal string + filename

# Comparing two files: save checksums and compare using diff

shasum file1.txt > hash1.txt
shasum file2.txt > hash2.txt
diff hash1.txt hash2.txt
# No output = identical files

# ðŸ“ Notes:
# - If md5 is unavailable, use shasum (default on Ubuntu).
# - Useful for checking downloads or ensuring no unintended changes.


# PIPES (|) â€“ CONNECTING COMMANDS IN THE SHELL

# Pipes allow chaining commands: output of one becomes input of the next.
# Symbol: |  (Usually Shift + \)

# ðŸ“Œ Basic usage:
# The output of the left-hand command becomes the input for the right-hand one.

# Example 1 â€“ Count how many US states end in a vowel:
grep "[aeiou]$" states.txt | wc -l
# â†’ 32

# Explanation:
# - grep "[aeiou]$" finds all lines ending in a vowel
# - wc -l counts the number of matching lines

# Example 2 â€“ Combine 3 commands:
ls -l | grep "Feb" | less
# â†’ List all files modified in February and view them scrollably with less

# Notes:
# - You can chain multiple pipes
# - Pipes make command-line workflows much more powerful and readable

# ðŸ§  Count Unique Commands from History

# This command counts how many unique commands you've ever used:
cat ~/.bash_history | sort | uniq | wc -l

# Explanation:
# - 'cat ~/.bash_history' prints your command history.
# - 'sort' arranges the lines alphabetically.
# - 'uniq' removes repeated adjacent commands.
# - 'wc -l' counts the number of unique lines (i.e., commands).

# Optional: To count only unique command names (ignoring arguments):
cut -d' ' -f1 ~/.bash_history | sort | uniq | wc -l




# === Summary: Make and Makefiles ===
# The 'make' command automates tasks like building files or running scripts by checking file dependencies.

# A makefile is a plain text file that defines "rules" in the following format:
# target: dependencies
#     commands (must be TAB-indented)

# Example 1: Create a file if it doesn't exist
draft_journal_entry.txt:
	touch draft_journal_entry.txt

# Example 2: Build a file based on another (dependency)
readme.txt: toc.txt
	echo "This journal contains the following number of entries:" > readme.txt
	wc -l toc.txt | egrep -o "[0-9]+" >> readme.txt

# If 'toc.txt' is modified, and we run `make readme.txt`,
# then 'readme.txt' will be rebuilt with the updated line count.

# Example 3: Use the 'all' rule to group multiple targets:
all: draft_journal_entry.txt readme.txt

# Now, running just `make` will trigger both targets.

# Example 4: Add a 'clean' rule to delete generated files:
clean:
	rm draft_journal_entry.txt
	rm readme.txt

# This lets you reset your directory using:
#   make clean

# The main idea: 'make' checks timestamps.
# If the target file is missing or outdated (older than its dependencies), the rule is executed.
# Otherwise, it skips the command and prints: "is up to date".
