ðŸ—’ï¸ UNIX WORKBENCH â€“ 
DAY 1 SUMMARY

ðŸ“‚ Navigating Directories:
- pwd â†’ prints current location
- cd ~ â†’ go to home directory
- cd / â†’ go to root directory
- cd folder_name â†’ enter a subdirectory
- cd .. â†’ move one directory up
- cd /path/to/folder â†’ absolute path navigation

ðŸ“„ Folder Management:
- mkdir folder_name â†’ create directory
- ls â†’ list files and folders
- rm -r folder_name â†’ delete directory (carefulâ€”no confirmation)

ðŸ§­ Paths:
- Absolute path: starts with / (e.g., /mnt/c/BioEdit)
- Relative path: based on current directory (e.g., ../other_folder)

âŒ¨ï¸ Tab Completion:
- Tab completes folder/file names
- Double Tab â†’ lists all matching options

ðŸªŸ Accessing Windows from Linux:
- /mnt/c/... â†’ access Windows C drive
- Example: cd /mnt/c/Users/Shalev/Desktop

ðŸ“Ž Tips:
- Use pwd to verify location
- Use ls to see contents before cd
- Avoid rm -r unless youâ€™re sure


ðŸ—’ï¸ UNIX WORKBENCH â€“ DAY 2 SUMMARY

UNIX WORKBENCH â€“ DAY 2 SUMMARY

File and Directory Management:
------------------------------
mkdir my_folder
    â†’ Create a new directory named 'my_folder'

touch notes.txt
    â†’ Create an empty file named 'notes.txt'

cp notes.txt backup.txt
    â†’ Copy file to a new file named 'backup.txt'

mv backup.txt archive/
    â†’ Move file to a folder or rename it

rm notes.txt
rm -r archive/
    â†’ Delete file or folder (with all contents). Use carefully.

Writing and Appending to Files:
-------------------------------
echo "Hello" > file.txt
    â†’ Write to file (overwrites existing content)

echo "Another line" >> file.txt
    â†’ Append new content to the end of the file

Viewing File Content:
---------------------
cat file.txt
    â†’ Print the full content of the file

head file.txt
    â†’ Print the first 10 lines of the file

tail file.txt
    â†’ Print the last 10 lines of the file

less file.txt
    â†’ Scroll through file content (use q to quit)

File Statistics:
----------------
wc file.txt
    â†’ Print number of lines, words, and characters

Output Redirection:
-------------------
ls ~ > list.txt
    â†’ Save a list of files in the home directory to list.txt

ls ~ >> list.txt
    â†’ Append the file list to the same file

Module 2

Help and Manual:
----------------
man ls
    â†’ Show help documentation for a command

apropos calendar
    â†’ Search for commands related to a keyword

Wildcards:
----------
ls *.txt
    â†’ List all files ending with .txt

rm temp*
    â†’ Delete all files starting with 'temp'

Trash Recommendation:
---------------------
mkdir -p ~/.Trash
mv file.txt ~/.Trash/
    â†’ Instead of deleting a file, move it to a custom Trash folder

Tips:
-----
- Use pwd to verify current location
- Use ls to check contents before using cd
- Avoid rm -r unless you're completely sure


REGULAR EXPRESSIONS & TEXT SEARCHING:

ðŸ” Basic Commands:
- grep "pattern" filename        â†’ search for lines matching pattern
- egrep "pattern" filename       â†’ like grep, but supports extended regex
- find /path -name "filename"    â†’ search for file names in directories

# The -i flag in egrep (or grep) makes the search case-insensitive.
# This means it ignores the difference between uppercase and lowercase letters.

# The following command finds lowercase or uppercase:
egrep -i "^[aeiou]" states.txt
# This is equivalent to writing:
egrep "^[AEIOUaeiou]" states.txt

ðŸ§  Common Regex Metacharacters:
.       â†’ Any single character
\w      â†’ Word character (a-z, A-Z, 0-9, _)
\W      â†’ Not a word character
\d      â†’ Digit (0â€“9)
\D      â†’ Not a digit
\s      â†’ Whitespace (space, tab, etc.)
\S      â†’ Not whitespace
\n      â†’ Newline

ðŸ”£ Sets and Ranges:
[abc]   â†’ Match 'a' or 'b' or 'c'
[^abc]  â†’ Match anything except 'a', 'b', or 'c'
[a-z]   â†’ Range from 'a' to 'z'

ðŸ“ Anchors:
^       â†’ Start of string "^[aeiou]" / "^M"
$       â†’ End of string "[aeiou]$"

ðŸ”¢ Quantifiers:
+       â†’ One or more of the previous
*       â†’ Zero or more of the previous
?       â†’ Zero or one of the previous
{n}     â†’ Exactly n occurrences
{m,n}   â†’ Between m and n occurrences
{m,}    â†’ m or more occurrences

ðŸ” Alternation:
|       â†’ OR between expressions (e.g. food|bar)

ðŸ§ª Examples:
egrep "s+as" states.txt  
â†’ Matches lines with 's' repeated 1+ times followed by 'as'  
  â†’ Matches: Kansas, Arkansas

egrep "\d" small.txt  
â†’ Matches lines containing digits

egrep "\W" small.txt  
â†’ Matches lines containing symbols or spaces (non-word characters)

egrep "New" states.txt  
â†’ Matches: New York, New Mexico, etc.

ðŸ“Œ Tip:
Use `egrep -v` to invert the match (i.e. return non-matching lines)



# ðŸ“˜ Bash History and Aliases Summary

# View command history in the current terminal session
history

# View full command history saved across sessions
cat ~/.bash_history

# Create an alias for a frequently used command
alias ll="ls -lh"

# Make aliases persist across sessions by adding them to this file:
~/.bash_profile

# Example: Add the following line to ~/.bash_profile
# alias gs="git status"

# To apply changes without restarting the shell:
source ~/.bash_profile

# Tip:
# Use `history | grep keyword` to search past commands


# ðŸ” Hashing and File Integrity Verification

# shasum â€“ generates a SHA-1 checksum (hash) based on file content.
# Useful to verify file authenticity and detect corruption.

# Syntax:
shasum filename

# Example:
shasum file1.txt
# Output: a long hexadecimal string + filename

# Comparing two files: save checksums and compare using diff

shasum file1.txt > hash1.txt
shasum file2.txt > hash2.txt
diff hash1.txt hash2.txt
# No output = identical files

# ðŸ“ Notes:
# - If md5 is unavailable, use shasum (default on Ubuntu).
# - Useful for checking downloads or ensuring no unintended changes.


# PIPES (|) â€“ CONNECTING COMMANDS IN THE SHELL

# Pipes allow chaining commands: output of one becomes input of the next.
# Symbol: |  (Usually Shift + \)

# ðŸ“Œ Basic usage:
# The output of the left-hand command becomes the input for the right-hand one.

# Example 1 â€“ Count how many US states end in a vowel:
grep "[aeiou]$" states.txt | wc -l
# â†’ 32

# Explanation:
# - grep "[aeiou]$" finds all lines ending in a vowel
# - wc -l counts the number of matching lines

# Example 2 â€“ Combine 3 commands:
ls -l | grep "Feb" | less
# â†’ List all files modified in February and view them scrollably with less

# Notes:
# - You can chain multiple pipes
# - Pipes make command-line workflows much more powerful and readable

# ðŸ§  Count Unique Commands from History

# This command counts how many unique commands you've ever used:
cat ~/.bash_history | sort | uniq | wc -l

# Explanation:
# - 'cat ~/.bash_history' prints your command history.
# - 'sort' arranges the lines alphabetically.
# - 'uniq' removes repeated adjacent commands.
# - 'wc -l' counts the number of unique lines (i.e., commands).

# Optional: To count only unique command names (ignoring arguments):
cut -d' ' -f1 ~/.bash_history | sort | uniq | wc -l


# --------------------------------
# === Summary: Make and Makefiles ===
# The 'make' command automates tasks like building files or running scripts by checking file dependencies.

# A makefile is a plain text file that defines "rules" in the following format:
# target: dependencies
#     commands (must be TAB-indented)

# Example 1: Create a file if it doesn't exist
draft_journal_entry.txt:
	touch draft_journal_entry.txt

# Example 2: Build a file based on another (dependency)
readme.txt: toc.txt
	echo "This journal contains the following number of entries:" > readme.txt
	wc -l toc.txt | egrep -o "[0-9]+" >> readme.txt

# If 'toc.txt' is modified, and we run `make readme.txt`,
# then 'readme.txt' will be rebuilt with the updated line count.

# Example 3: Use the 'all' rule to group multiple targets:
all: draft_journal_entry.txt readme.txt

# Now, running just `make` will trigger both targets.

# Example 4: Add a 'clean' rule to delete generated files:
clean:
	rm draft_journal_entry.txt
	rm readme.txt

# This lets you reset your directory using:
#   make clean

# The main idea: 'make' checks timestamps.
# If the target file is missing or outdated (older than its dependencies), the rule is executed.
# Otherwise, it skips the command and prints: "is up to date".

# Math:
#!/usr/bin/env bash
# The line '#!/usr/bin/env bash' tells the system to run the script using Bash,
# locating it via the environment for better portability across systems.

# --------------------------------
# Summary: Arithmetic in Bash

# Bash scripts run line by line, from top to bottom.
# Anything after a '#' is a comment and not executed.

# The 'expr' command lets you perform simple integer arithmetic:
expr 5 + 2     # 7
expr 5 - 2     # 3
expr 5 \* 2    # 10 (note: the '*' must be escaped with a backslash)
expr 5 / 2     # 2 (Bash does integer division only)

# Integer division always rounds down:
expr 1 / 3     # 0
expr 10 / 3    # 3

# Use '%' for modulus (remainder) operations:
expr 10 % 3    # 1
expr 40 % 21   # 19

# For floating-point arithmetic, use 'bc' with the -l (math library) flag:
echo "22 / 7" | bc -l           # 3.142857...
echo "4.2 * 9.15" | bc -l       # 38.4300
echo "(6.5 / 0.5) + (6 * 2.2)" | bc -l  # 21.4

# 'bc' allows you to calculate with decimals by piping math expressions into it.

# You can use 'bc -l' in two main ways:

# 1. Interactive mode:
# Type 'bc -l' in the terminal and enter math expressions manually.
# Example:
# bc -l
# 22 / 7
# sqrt(2)
# quit

# 2. Piping expressions from a file:
# Write expressions in a plain text file (e.g., bigmath.sh), one per line:
# 22 / 7
# sqrt(2)
# 10^2
# Then run:
cat bigmath.sh | bc -l
# 'cat' reads the file, '|' sends it to 'bc -l' for decimal calculations.

# --------------------------------
# Summary: Variables in Bash

# Variables are assigned using '=' with no spaces:
chapter_number=5      # valid
# chapter_number = 5  â†’ invalid (will cause an error)

# Access variable values using the $ prefix:
echo $chapter_number  # 5

# Modify numeric variables using 'let':
let chapter_number=$chapter_number+1
echo $chapter_number  # 6

# Store strings in variables:
the_empire_state="New York"
echo $the_empire_state  # New York

# Insert variable into a sentence:
echo "I went to school in $the_empire_state."
# Output: I went to school in New York.

# Command substitution: run a command and store its output in a variable
math_lines=$(cat math.sh | wc -l)
echo $math_lines       # Number of lines in math.sh

# Bash scripts can receive command line arguments:

# --------------------------------
# Example script (vars.sh):

# #!/usr/bin/env bash
# echo "Script arguments: $@"
# echo "First arg: $1. Second arg: $2."
# echo "Number of arguments: $#"

# Example runs:
# bash vars.sh red blue
# Output:
# Script arguments: red blue
# First arg: red. Second arg: blue.
# Number of arguments: 2

# $1 is the first argument, $2 the second, $@ is all args, $# is the count

# --------------------------------
# Example - Assigning and printing variables in Bash
#!/usr/bin/env bash

# Numbers can be stored using command substitution:
a=$(expr 2 + 2)
b=$(expr 1 + 2)

# Or with 'let':
let a=2+2
let b=1+2

# Or with arithmetic expansion:
a=$((2 + 2))
b=$((1 + 2))

echo "$a $b"     # Print both numbers on the same line
echo "$a"        # Print each number separately
echo "$b"

# Strings can be assigned directly:
first_name="Shalev"
last_name="Yaacov"

# Print both strings on the same line:
echo "$first_name $last_name"
# --------------------------------

# Task Example: Write a Bash program that multiplies the number of arguments ($#) by the first argument ($1), and prints the result.
# Important: Bash doesn't evaluate expressions like "echo "$# * $1"" as math.
# Without 'let' or $((...)), Bash treats it as plain text (a string), not a calculation.

let noa=$#        # number of arguments
let fa=$1         # first argument
let final_1=$noa\*$fa
echo "$final_1"   # prints the result of $# * $1
let

# You can also do it in one line:
let final_2=$#\*$1
echo "$final_2"

# Example:
# bash script.sh 3 5
# â†’ Number of arguments: 2
# â†’ First arg: 3
# â†’ 6 (because 2 * 3 = 6)

# --------------------------------

# Summary: User input with 'read'

# The 'read' command pauses the script and waits for user input.
# The input is stored in a variable of your choice.

# Example:
echo "Type in a string and then press Enter:"
read response
echo "You entered: $response"

# When run, the script waits for user input.
# After typing (e.g., Hello!) and pressing Enter, it outputs:
# You entered: Hello!

# This is useful for interactive Bash scripts that ask users for input at runtime.
# --------------------------------

# Example: Using 'read' to collect words and build a sentence

# This script asks the user for an adjective, a noun, and a verb,
# then combines them into a sentence (like a simple Mad Libs game).

echo "Enter an adjective:"
read adj

echo "Enter a noun:"
read noun

echo "Enter a verb:"
read verb

echo "The $adj $noun likes to $verb every morning."
# --------------------------------


# Summary: Conditionals and comparisons in Bash

# Every Bash command returns an exit status:
# 0 = success (true), non-zero = failure (false)
true     # returns 0
false    # returns 1

# Conditional execution:
# cmd1 && cmd2 â†’ run cmd2 only if cmd1 succeeds
# cmd1 || cmd2 â†’ run cmd2 only if cmd1 fails

# Conditional expressions are written in [[ ... ]].
# They return 0 (true) if the condition is met, 1 (false) otherwise.

# Example:
x=5
if [[ $x -gt 3 ]]; then
  echo "x is greater than 3"
fi

# Comparison flags:
# -gt : greater than         [[ $a -gt 3 ]]
# -ge : greater or equal     [[ $a -ge 3 ]]
# -lt : less than            [[ $a -lt 3 ]]
# -le : less or equal        [[ $a -le 3 ]]
# -eq : equal                [[ $a -eq 3 ]]
# -ne : not equal            [[ $a -ne 3 ]]

# File/string tests:
# -e  : file exists          [[ -e file.txt ]]
# -d  : directory exists     [[ -d folder ]]
# -z  : string is empty      [[ -z $str ]]
# -n  : string is not empty  [[ -n $str ]]

# String and regex comparisons:
# =    : equal               [[ $name = "Bob" ]]
# !=   : not equal           [[ $name != "Alice" ]]
# =~   : regex match         [[ $input =~ ^[0-9]+$ ]]
# !    : not                 [[ ! -e file.txt ]]

# Control flow:
if [[ condition ]]; then
  # code if condition is true
elif [[ other_condition ]]; then
  # alternative
else
  # fallback
fi

# --------------------------------
# Summary: Logic and If/Else Exercises in Bash
#!/usr/bin/env bash

# 1. Check if a string starts with a capital letter
# This uses regex and [[ ... ]] to test if the first character is uppercase.

input=$1
if [[ $input =~ ^[A-Z] ]]; then
  echo "how proper"
fi
# ðŸ”¹ Note: ^[A-Z] matches strings starting with a capital letter.
# ------------------------------

# 2. Print "even" or "odd" based on input number
# Use modulus (%) to check parity.

num=$1
let remainder=$num%2
if [[ $remainder -eq 0 ]]; then
  echo "even"
else
  echo "odd"
fi
# ðŸ”¹ Tip: Arithmetic must be done using 'let' or $((...)). Don't expect "$a * $b" to calculate.
# ------------------------------

# 3. If both arguments are numbers, print their sum. Otherwise, print both arguments.

x=$1
y=$2
if [[ $x =~ ^[0-9]+$ && $y =~ ^[0-9]+$ ]]; then
  let sum=$x+$y
  echo "$sum"
else
  echo "$x"
  echo "$y"
fi
# ðŸ”¹ Note:
# - The regex ^[0-9]+$ ensures the entire string is numeric.
# - [[ ... && ... ]] allows combining multiple conditions.
# ------------------------------

# 4. Print a message only if today is Friday

day=$(date +%a)
if [[ $day == "Fri" ]]; then
  echo "Thank Moses it's Friday"
fi
# ðŸ”¹ Use 'date +%a' to extract the day abbreviation (e.g., Mon, Tue, Fri)
# ------------------------------

